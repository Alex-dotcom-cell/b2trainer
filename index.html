<!doctype html>
<html lang="ru">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>B2 German Exam Trainer — Offline-ready</title>

  <!-- Tailwind CDN (simple) -->
  <script src="https://cdn.tailwindcss.com"></script>

  <!-- React & ReactDOM (UMD) -->
  <script crossorigin src="https://unpkg.com/react@18/umd/react.development.js"></script>
  <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
  <!-- Babel for JSX in-browser (single-file convenience) -->
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>

  <style>
    /* Small extra polish for the Pro style */
    body { font-family: Inter, ui-sans-serif, system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial; }
    .btn-icon { width: 2.25rem; height: 2.25rem; display: inline-flex; align-items:center; justify-content:center; border-radius: 9999px; }
    .card { background: white; border: 1px solid rgba(15,23,42,0.06); border-radius: 12px; padding: 1rem; box-shadow: 0 6px 20px rgba(2,6,23,0.04); }
    pre { white-space: pre-wrap; word-break: break-word; }
  </style>
</head>
<body class="bg-gray-50 p-6">

  <div id="root" class="max-w-6xl mx-auto"></div>

  <script type="text/babel">
  // B2 Trainer — Single-file React app (Pro style, Gemini TTS + fallback)
  const { useState, useEffect, useMemo, useCallback } = React;

  /* ----------------------------
     === CONFIG ===
     ---------------------------- */
  const API_CONFIG = {
    MODEL: "gemini-2.5-flash-preview-tts",
    API_URL: "https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-tts:generateContent",
    // <-- ТВОЙ API-ключ (вставлен по просьбе)
    API_KEY: "AIzaSyCwMwNa3CFyxfev2q40_e9jFhfgL3XUN2Q"
  };

  /* ----------------------------
     === DATA (Schreiben & Sprechen) ===
     (сокращённо/структурировано — весь критичный контент сохранён)
     ---------------------------- */

  const SCHREIBEN_TOPICS = [
    { id: 'produkt', ru: '1. Товар (дефект)', de: 'der neue Staubsauger' },
    { id: 'service', ru: '2. Услуга (обслуживание)', de: 'Ihr Internetanschluss' },
    { id: 'kurs', ru: '3. Курс/Школа (недостатки)', de: 'der Deutsch B2-Kurs' },
    { id: 'reise', ru: '4. Путешествие/Отель (недостатки)', de: 'das gebuchte Hotelzimmer' },
    { id: 'wohnung', ru: '5. Дефект в квартире', de: 'die Heizungsanlage in meiner Wohnung' },
    { id: 'rechnung', ru: '6. Счет/Договор (ошибка)', de: 'meine letzte Rechnung' },
    { id: 'transport', ru: '7. Транспорт (задержка/проблема)', de: 'die Bahnverbindung nach Berlin' },
  ];

  const PHRASES_DATA = {
    greetings: [ { id: 101, text: "Sehr geehrte Damen und Herren,", ru: "Уважаемые дамы и господа,", tip: "Формальное обращение." } ],
    issue_intro: [
      { id: 201, text: "Ich schreibe Ihnen bezüglich [объект жалобы].", ru: "Я пишу Вам по поводу [объект жалобы].", tip: "Предлог 'bezüglich' — Genitiv." },
      { id: 202, text: "Ich beziehe mich auf unsere Bestellung/Vereinbarung vom [Дата].", ru: "Я ссылаюсь на наш заказ/договоренность от [Дата].", tip: "sich beziehen auf + Akk." }
    ],
    main_problem: [
      { id: 301, text: "Leider muss ich Ihnen mitteilen, dass [объект жалобы] nicht der Beschreibung entspricht.", ru: "К сожалению, [объект жалобы] не соответствует описанию.", tip: "Придаточное с 'dass' — глагол в конце." },
      { id: 302, text: "Der Hauptgrund für meine Beschwerde ist, dass es Mängel gibt.", ru: "Причина жалобы — наличие недостатков.", tip: "Mängel — мн. число." }
    ],
    problem_consequence: [
      { id: 401, text: "Aufgrund dieses Problems konnte ich meine Arbeit nicht wie geplant durchführen.", ru: "Из-за этой проблемы я не смог выполнить работу как планировал.", tip: "Aufgrund + Genitiv." },
      { id: 402, text: "Das hat bei mir zu großem Ärger und Unannehmlichkeiten geführt.", ru: "Это привело к большим неудобствам.", tip: "Устойчивые выражения." }
    ],
    evidence: [
      { id: 501, text: "Ich habe Ihnen alle notwendigen Unterlagen in der Anlage beigefügt.", ru: "Я приложил все необходимые документы.", tip: "beifügen — Perfekt: habe beigefügt." },
      { id: 502, text: "Ich möchte Sie bitten, die Angelegenheit innerhalb von 14 Tagen zu klären.", ru: "Прошу решить вопрос в течение 14 дней.", tip: "Infinitivkonstruktion mit 'zu'." }
    ],
    resolution_request: [
      { id: 601, text: "Daher bitte ich Sie höflich um eine schnelle Lösung und um Ersatz.", ru: "Прошу срочного решения и замены.", tip: "Daher — следствие." },
      { id: 602, text: "Falls dies nicht möglich ist, erwarte ich die volle Rückerstattung des Kaufpreises.", ru: "Если невозможно — ожидаю возврата средств.", tip: "Falls = если." }
    ],
    closing_formula: [ { id: 701, text: "Ich danke Ihnen für Ihre Mühe und hoffe auf eine schnelle Klärung.", ru: "Благодарю за внимание и надеюсь на быстрое решение.", tip: "Спасибо + надежда." } ],
    sign_off: [ { id: 801, text: "Mit freundlichen Grüßen,", ru: "С уважением,", tip: "Стандартная подпись." } ],
  };

  const SPRECHEN_SCENARIOS = [
    {
      id: 'thema1',
      title_ru: 'Тема 1: Описание работодателя',
      title_de: 'Thema 1: Arbeitgeber beschreiben',
      dialogues: [
        {
          id: '1a',
          title_ru: 'A. Международная IT-компания',
          text_de: `A: Ich möchte über einen Arbeitgeber sprechen, bei dem ich gerne arbeiten würde – ein internationales IT-Unternehmen.
B: Klingt spannend. In welcher Branche ist das Unternehmen tätig?
A: Es entwickelt Softwarelösungen für große Firmen, zum Beispiel für Banken und Versicherungen.
B: Und welche Abteilungen gibt es dort?
A: Es gibt eine Entwicklungsabteilung, ein Marketingteam, den Kundenservice und die Personalabteilung.`,
          text_ru: `A: Я хочу рассказать о работодателе — международной IT-компании.
B: В какой отрасли она работает?
A: Она разрабатывает ПО для крупных компаний.
B: Какие отделы там есть?
A: Разработка, маркетинг, поддержка и HR.`
        }
      ]
    },
    // Можно добавить больше тем — в файле репозитория у тебя полный список
  ];

  const initialActiveScenario = SPRECHEN_SCENARIOS[0];

  /* ----------------------------
     === UTILS: TTS & audio helpers ===
     ---------------------------- */

  // Base64 -> ArrayBuffer
  function base64ToArrayBuffer(base64) {
    try {
      const binary = atob(base64);
      const len = binary.length;
      const bytes = new Uint8Array(len);
      for (let i = 0; i < len; i++) bytes[i] = binary.charCodeAt(i);
      return bytes.buffer;
    } catch (e) {
      return null;
    }
  }

  function pcmToWav(pcm16, sampleRate = 24000) {
    const numChannels = 1;
    const bytesPerSample = 2;
    const wavBuffer = new ArrayBuffer(44 + pcm16.length * bytesPerSample);
    const view = new DataView(wavBuffer);
    let offset = 0;
    function writeString(str) {
      for (let i = 0; i < str.length; i++) view.setUint8(offset++, str.charCodeAt(i));
    }
    writeString('RIFF'); view.setUint32(offset, 36 + pcm16.length * bytesPerSample, true); offset += 4;
    writeString('WAVE');
    writeString('fmt '); view.setUint32(offset, 16, true); offset += 4;
    view.setUint16(offset, 1, true); offset += 2; // PCM
    view.setUint16(offset, numChannels, true); offset += 2;
    view.setUint32(offset, sampleRate, true); offset += 4;
    view.setUint32(offset, sampleRate * numChannels * bytesPerSample, true); offset += 4;
    view.setUint16(offset, numChannels * bytesPerSample, true); offset += 2;
    view.setUint16(offset, bytesPerSample * 8, true); offset += 2;
    writeString('data'); view.setUint32(offset, pcm16.length * bytesPerSample, true); offset += 4;
    for (let i = 0; i < pcm16.length; i++) { view.setInt16(offset, pcm16[i], true); offset += 2; }
    return new Blob([wavBuffer], { type: 'audio/wav' });
  }

  // Функция: попытаться получить TTS через Gemini API
  async function callGeminiTTS(text, voice = "Kore", apiKey = API_CONFIG.API_KEY) {  // ИЗМЕНЕНО: "Kore" вместо "Fenrir"
    if (!apiKey) throw new Error("API key missing");
    const payload = {
      contents: [{ parts: [{ text }] }],
      generationConfig: {
        responseModalities: ["AUDIO"],
        speechConfig: {
          voiceConfig: {
            prebuiltVoiceConfig: { voiceName: voice }
          }
        }
      },
      model: API_CONFIG.MODEL
    };

    const res = await fetch(`${API_CONFIG.API_URL}?key=${apiKey}`, {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify(payload)
    });

    const raw = await res.text();
    if (!raw) throw new Error(`Empty response, status ${res.status}`);
    let parsed;
    try { parsed = JSON.parse(raw); } catch (e) { throw new Error("Non-JSON response from TTS API"); }

    if (!res.ok) {
      const msg = parsed?.error?.message || `HTTP ${res.status}`;
      throw new Error(msg);
    }

    // Ожидаем структуру: parsed.candidates[0].content.parts[0].inlineData.data
    const part = parsed?.candidates?.[0]?.content?.parts?.[0];
    const base64 = part?.inlineData?.data;
    const mime = part?.inlineData?.mimeType || "";
    if (!base64) throw new Error("No audio data in response");
    return { base64, mime };
  }

  // Fallback: Web Speech API (if available). Returns Promise that resolves when finished.
  function speakWithWebSpeech(text, lang = "de-DE") {
    return new Promise((resolve, reject) => {
      if (!("speechSynthesis" in window)) return reject(new Error("SpeechSynthesis not supported"));
      const u = new SpeechSynthesisUtterance(text);
      u.lang = lang;
      u.onend = () => resolve();
      u.onerror = (e) => reject(e);
      window.speechSynthesis.cancel(); // stop previous
      window.speechSynthesis.speak(u);
    });
  }

  /* ----------------------------
     === UI: small icons as SVG strings ===
     ---------------------------- */
  const Icon = {
    Volume: (props) => (
      <svg viewBox="0 0 24 24" width="18" height="18" fill="none" stroke="currentColor" strokeWidth="1.6" strokeLinecap="round" strokeLinejoin="round" {...props}>
        <path d="M11 5L6 9H2v6h4l5 4V5z"></path>
        <path d="M19 5c.4 1.1.5 2.3.5 3.5s-.1 2.4-.5 3.5"></path>
        <path d="M15 9.5c.3.8.5 1.7.5 2.5s-.2 1.7-.5 2.5"></path>
      </svg>
    ),
    Refresh: (props) => (
      <svg viewBox="0 0 24 24" width="16" height="16" fill="none" stroke="currentColor" strokeWidth="1.6" strokeLinecap="round" strokeLinejoin="round" {...props}>
        <path d="M21 12a9 9 0 1 0-3.2 6.7L21 18"></path>
        <path d="M21 12v6h-6"></path>
      </svg>
    ),
    Loader: (props) => (
      <svg viewBox="0 0 24 24" width="16" height="16" className="animate-spin" {...props}>
        <circle cx="12" cy="12" r="10" stroke="currentColor" strokeWidth="2" fill="none" strokeDasharray="31.4 31.4" strokeLinecap="round"></circle>
      </svg>
    ),
    Edit: (props) => (
      <svg viewBox="0 0 24 24" width="16" height="16" fill="none" stroke="currentColor" strokeWidth="1.6" strokeLinecap="round" strokeLinejoin="round" {...props}>
        <path d="M12 20h9"></path>
        <path d="M16.5 3.5a2.1 2.1 0 0 1 3 3L8 18l-4 1 1-4 11.5-11.5z"></path>
      </svg>
    ),
    Message: (props) => (
      <svg viewBox="0 0 24 24" width="16" height="16" fill="none" stroke="currentColor" strokeWidth="1.6" strokeLinecap="round" strokeLinejoin="round" {...props}>
        <path d="M21 15a2 2 0 0 1-2 2H7l-4 4V5a2 2 0 0 1 2-2h14a2 2 0 0 1 2 2z"></path>
      </svg>
    )
  };

  /* ----------------------------
     === React App ===
     ---------------------------- */

  function App() {
    // default view: Schreiben (as requested)
    const [view, setView] = useState('schreiben'); // 'schreiben' or 'sprechen'

    // Schreiben state
    const initialSelections = useMemo(() => ({
      greetings: PHRASES_DATA.greetings[0].id,
      issue_intro: PHRASES_DATA.issue_intro[0].id,
      main_problem: PHRASES_DATA.main_problem[0].id,
      problem_consequence: PHRASES_DATA.problem_consequence[0].id,
      evidence: PHRASES_DATA.evidence[0].id,
      resolution_request: PHRASES_DATA.resolution_request[0].id,
      closing_formula: PHRASES_DATA.closing_formula[0].id,
      sign_off: PHRASES_DATA.sign_off[0].id,
    }), []);

    const [selections, setSelections] = useState(initialSelections);
    const [activeTopic, setActiveTopic] = useState(SCHREIBEN_TOPICS[0]);
    const [senderName, setSenderName] = useState("Ivan Ivanov");
    const [invoiceNumber, setInvoiceNumber] = useState("RE-2024-5829");
    const [currentDate] = useState(new Date().toLocaleDateString('de-DE'));

    // Sprechen state
    const [activeScenario, setActiveScenario] = useState(initialActiveScenario);
    const [activeDialogue, setActiveDialogue] = useState(initialActiveScenario.dialogues[0]);

    // audio & tts state
    const [audioUrl, setAudioUrl] = useState(null);
    const [isLoading, setIsLoading] = useState(false);
    const [error, setError] = useState(null);

    // helper: find phrase by id
    const allPhrases = useMemo(() => Object.values(PHRASES_DATA).flat(), []);
    const findPhraseById = (id) => allPhrases.find(p => p.id === id);

    const replacePlaceholder = useCallback((text) => {
      if (!text) return '';
      return text.replace(/\[объект жалобы\]/g, activeTopic.de).replace(/\[Дата\]/g, currentDate);
    }, [activeTopic, currentDate]);

    function assembleLetterText() {
      const parts = [
        replacePlaceholder(findPhraseById(selections.greetings)?.text || ''),
        replacePlaceholder(findPhraseById(selections.issue_intro)?.text || ''),
        replacePlaceholder(findPhraseById(selections.main_problem)?.text || ''),
        replacePlaceholder(findPhraseById(selections.problem_consequence)?.text || ''),
        replacePlaceholder(findPhraseById(selections.evidence)?.text || ''),
        replacePlaceholder(findPhraseById(selections.resolution_request)?.text || ''),
        replacePlaceholder(findPhraseById(selections.closing_formula)?.text || ''),
        replacePlaceholder(findPhraseById(selections.sign_off)?.text || ''),
        senderName
      ];
      return parts.filter(Boolean).join("\n\n");
    }

    // --- TTS orchestration: try Gemini, if fails -> Web Speech fallback ---
    const speakText = async (text, voice = "Kore") => {  // ИЗМЕНЕНО: "Kore" вместо "Fenrir"
      setError(null);
      if (!text || text.trim().length === 0) return;
      setIsLoading(true);
      setAudioUrl(null);

      // First: try Gemini
      try {
        const { base64, mime } = await callGeminiTTS(text, voice, API_CONFIG.API_KEY);
        const arrBuf = base64ToArrayBuffer(base64);
        if (!arrBuf) throw new Error("Cannot decode base64 audio");
        const pcm = new Int16Array(arrBuf);
        const wavBlob = pcmToWav(pcm, 24000);
        const url = URL.createObjectURL(wavBlob);
        setAudioUrl(url);
        // auto-play
        const a = new Audio(url);
        await a.play().catch(e => console.warn("Play error:", e));
      } catch (gErr) {
        // fallback to Web Speech
        console.warn("Gemini TTS failed, fallback to Web Speech:", gErr);
        try {
          await speakWithWebSpeech(text, "de-DE");
        } catch (wsErr) {
          console.error("WebSpeech failed:", wsErr);
          setError("Озвучивание недоступно (проверьте интернет или настройки браузера).");
        }
      } finally {
        setIsLoading(false);
      }
    };

    // Sprechen: parse dialogue lines (DE / RU)
    const parseDialogueLines = (deText, ruText) => {
      const deLines = (deText || "").split('\n').map(l => l.trim()).filter(Boolean);
      const ruLines = (ruText || "").split('\n').map(l => l.trim()).filter(Boolean);
      return deLines.map((de, i) => {
        const speakerMatch = de.match(/^(A:|B:)/);
        const speaker = speakerMatch ? speakerMatch[0] : "A:";
        const de_text = de.replace(/^(A:|B:)\s*/, '');
        const ru_text = ruLines[i] ? ruLines[i].replace(/^(A:|B:)\s*/, '') : '';
        return { id: i, speaker, de_text, ru_text, voice: "Kore" };  // ИЗМЕНЕНО: все голоса "Kore"
      });
    };

    // parsed dialogue for UI
    const parsedDialogue = useMemo(() => parseDialogueLines(activeDialogue.text_de, activeDialogue.text_ru), [activeDialogue]);

    // Clean up object URLs
    useEffect(() => {
      return () => { if (audioUrl) URL.revokeObjectURL(audioUrl); };
    }, [audioUrl]);

    // UI rendering
    return (
      <div className="space-y-6">
        <header className="text-center mb-4">
          <h1 className="text-3xl font-extrabold text-blue-800">B2 German Exam Trainer</h1>
          <p className="text-sm text-gray-600">Schreiben & Sprechen — Pro style</p>
        </header>

        <div className="flex justify-center mb-4">
          <div className="inline-flex bg-white rounded-xl shadow p-1">
            <button
              onClick={() => setView('schreiben')}
              className={`px-5 py-2 rounded-lg font-semibold ${view === 'schreiben' ? 'bg-blue-700 text-white' : 'text-gray-700 hover:bg-gray-100'}`}
            >
              <span className="inline-flex items-center mr-2"><svg className="w-4 h-4 mr-1" viewBox="0 0 24 24"><path d="M3 21v-2a4 4 0 0 1 4-4h10" stroke="currentColor" strokeWidth="1.6" fill="none"/></svg></span>
              Schreiben
            </button>
            <button
              onClick={() => setView('sprechen')}
              className={`px-5 py-2 rounded-lg font-semibold ${view === 'sprechen' ? 'bg-indigo-600 text-white' : 'text-gray-700 hover:bg-gray-100'}`}
            >
              <span className="inline-flex items-center mr-2"><svg className="w-4 h-4 mr-1" viewBox="0 0 24 24"><path d="M21 15a2 2 0 0 1-2 2H7l-4 4V5a2 2 0 0 1 2-2h14a2 2 0 0 1 2 2z" stroke="currentColor" strokeWidth="1.6" fill="none"/></svg></span>
              Sprechen
            </button>
          </div>
        </div>

        <main className="grid grid-cols-1 lg:grid-cols-3 gap-6">
          {/* LEFT column: controls (Schreiben) */}
          <div className="lg:col-span-1 space-y-4">
            <div className="card">
              <h3 className="text-lg font-semibold text-gray-800 mb-2">1. Выбор темы</h3>
              <select
                value={activeTopic.id}
                onChange={(e) => setActiveTopic(SCHREIBEN_TOPICS.find(t => t.id === e.target.value))}
                className="w-full p-3 rounded border border-gray-200"
              >
                {SCHREIBEN_TOPICS.map(t => <option key={t.id} value={t.id}>{t.ru} — {t.de}</option>)}
              </select>

              <div className="mt-4">
                <label className="block text-sm text-gray-600">Ваше Имя</label>
                <input className="w-full p-2 mt-1 border rounded" value={senderName} onChange={e => setSenderName(e.target.value)} />
              </div>

              <div className="mt-3">
                <label className="block text-sm text-gray-600">Номер счёта / заказа</label>
                <input className="w-full p-2 mt-1 border rounded" value={invoiceNumber} onChange={e => setInvoiceNumber(e.target.value)} />
              </div>

              <div className="mt-4">
                <button className="w-full bg-green-600 text-white py-2 rounded flex items-center justify-center" onClick={() => {
                  // randomize selections
                  const newSel = Object.keys(PHRASES_DATA).reduce((acc, key) => {
                    const items = PHRASES_DATA[key];
                    acc[key] = items[Math.floor(Math.random()*items.length)].id;
                    return acc;
                  }, {});
                  setSelections(newSel);
                }}>
                  <Icon.Refresh className="mr-2" /> Случайная комбинация
                </button>
              </div>
            </div>

            <div className="card">
              <h3 className="text-lg font-semibold mb-2">2. Фразы (выбери по очереди)</h3>
              <div className="space-y-3 max-h-96 overflow-y-auto pr-2">
                {Object.keys(PHRASES_DATA).map(categoryKey => (
                  <div key={categoryKey}>
                    <div className="text-sm font-semibold text-gray-700 mb-2">
                      {categoryKey === 'greetings' && '1. Приветствие'}
                      {categoryKey === 'issue_intro' && '2. Введение / Ссылка'}
                      {categoryKey === 'main_problem' && '3. Суть проблемы'}
                      {categoryKey === 'problem_consequence' && '4. Последствия'}
                      {categoryKey === 'evidence' && '5. Документы / срок'}
                      {categoryKey === 'resolution_request' && '6. Запрос решения'}
                      {categoryKey === 'closing_formula' && '7. Заключение'}
                      {categoryKey === 'sign_off' && '8. Подпись'}
                    </div>
                    <div className="space-y-2">
                      {PHRASES_DATA[categoryKey].map(phrase => {
                        const active = selections[categoryKey] === phrase.id;
                        return (
                          <div key={phrase.id} className={`p-3 rounded ${active ? 'bg-blue-50 border-2 border-blue-200' : 'bg-gray-50 border border-gray-100' } flex justify-between items-start`}>
                            <div>
                              <div className="font-medium">{replacePlaceholder(phrase.text)}</div>
                              <div className="text-sm text-gray-500 mt-1 italic">{phrase.ru}</div>
                            </div>
                            <div className="ml-3 flex flex-col items-end">
                              <button className="btn-icon bg-white border p-1 mb-2" title="Выбрать" onClick={() => {
                                setSelections(prev => ({ ...prev, [categoryKey]: phrase.id }));
                              }}>
                                <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="1.6"><path d="M20 6L9 17l-5-5"/></svg>
                              </button>
                              <button className="btn-icon bg-blue-600 text-white p-1" title="Озвучить" onClick={() => speakText(replacePlaceholder(phrase.text), "Kore")}>  {/* ИЗМЕНЕНО: "Kore" */}
                                {isLoading ? <Icon.Loader /> : <Icon.Volume />}
                              </button>
                            </div>
                          </div>
                        );
                      })}
                    </div>
                  </div>
                ))}
              </div>
            </div>
          </div>

          {/* CENTER + RIGHT columns */}
          <div className="lg:col-span-2 space-y-6">
            <div className="card">
              <div className="flex justify-between items-center mb-4">
                <h2 className="text-xl font-bold text-gray-800">Готовое письмо</h2>
                <div className="text-sm text-gray-600">Дата: {currentDate}</div>
              </div>

              <div className="bg-gray-50 p-4 rounded border border-gray-100 min-h-[220px] whitespace-pre-wrap text-gray-800">
                <pre className="m-0">{assembleLetterText()}</pre>
              </div>

              <div className="mt-4 flex gap-3">
                <button className="px-4 py-2 bg-blue-700 text-white rounded flex items-center" onClick={() => speakText(assembleLetterText(), "Kore")}>  {/* ИЗМЕНЕНО: "Kore" */}
                  {isLoading ? <Icon.Loader className="mr-2" /> : <Icon.Volume className="mr-2" />} Озвучить письмо
                </button>

                <button className="px-4 py-2 border rounded" onClick={() => {
                  // copy to clipboard
                  navigator.clipboard.writeText(assembleLetterText()).then(()=> {
                    alert("Письмо скопировано в буфер обмена");
                  });
                }}>Копировать</button>

                <a className="px-4 py-2 border rounded text-sm" href={"data:text/plain;charset=utf-8," + encodeURIComponent(assembleLetterText())} download="letter.txt">Скачать .txt</a>

                {audioUrl && (
                  <audio controls src={audioUrl} className="ml-auto" />
                )}
              </div>
            </div>

            {/* Sprechen module (diálogo) — shown when view === 'sprechen' */}
            <div className="card">
              <div className="flex justify-between items-center mb-3">
                <h3 className="text-lg font-semibold">{activeScenario.title_ru} — {activeScenario.title_de}</h3>
                <div className="flex items-center gap-2">
                  <select value={activeScenario.id} onChange={(e) => {
                    const s = SPRECHEN_SCENARIOS.find(x => x.id === e.target.value);
                    setActiveScenario(s);
                    setActiveDialogue(s.dialogues[0]);
                  }} className="p-2 border rounded">
                    {SPRECHEN_SCENARIOS.map(s => <option key={s.id} value={s.id}>{s.title_ru}</option>)}
                  </select>
                </div>
              </div>

              <div className="mb-3">
                {activeScenario.dialogues.length > 1 && (
                  <div className="flex gap-2 mb-3">
                    {activeScenario.dialogues.map(d => (
                      <button key={d.id} onClick={() => setActiveDialogue(d)} className={`px-3 py-1 rounded ${activeDialogue.id === d.id ? 'bg-indigo-600 text-white' : 'bg-gray-100'}`}>{d.title_ru}</button>
                    ))}
                  </div>
                )}
                <div className="text-sm text-gray-700 mb-2">{activeDialogue.title_ru}</div>

                <div className="space-y-2 max-h-64 overflow-y-auto pr-2">
                  {parsedDialogue.map(line => (
                    <div key={line.id} className={`p-3 rounded ${line.speaker === 'A:' ? 'bg-blue-50 border-blue-100' : 'bg-gray-50 border-gray-100' } flex justify-between items-start`}>
                      <div>
                        <div className="font-semibold"><span className="mr-2">{line.speaker}</span>{line.de_text}</div>
                        <div className="text-sm italic text-gray-600 mt-1">{line.ru_text}</div>
                      </div>
                      <div className="ml-3">
                        <button className="btn-icon bg-indigo-600 text-white p-1" title="Озвучить реплику" onClick={() => speakText(line.de_text, "Kore")}>  {/* ИЗМЕНЕНО: "Kore" */}
                          {isLoading ? <Icon.Loader /> : <Icon.Volume />}
                        </button>
                      </div>
                    </div>
                  ))}
                </div>

                <div className="mt-4 text-sm text-gray-600">
                  Совет: читай реплики вслух, повторяя интонацию и ключевые слова — это тренирует произношение и поток речи.
                </div>
              </div>
            </div>

          </div>
        </main>

        {error && (
          <div className="fixed bottom-6 right-6 bg-red-600 text-white px-4 py-2 rounded shadow">
            Ошибка: {error}
          </div>
        )}

        <footer className="text-center text-xs text-gray-500 mt-8">
          Сделано с ❤️ — автономная версия. TTS: Gemini (при наличии ключа) с fallback на Web Speech API.
        </footer>
      </div>
    );
  } // end App

  // Render
  const rootEl = document.getElementById('root');
  ReactDOM.createRoot(rootEl).render(<App />);

  </script>
</body>
</html>
